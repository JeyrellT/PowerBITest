# üîß FIX FINAL: Duplicaci√≥n de Quizzes en Historial

**Fecha:** 2025-10-19  
**Problema:** Quiz aparece duplicado en historial despu√©s de reiniciar y completar 1 solo quiz  
**Gravedad:** üî¥ CR√çTICA - Datos inflados, m√©tricas incorrectas

---

## üìã Problema Identificado

### S√≠ntomas Reportados

Usuario: _"Reinicie e hice un solo quiz. Este nuevo hice uno y se duplic√≥ el mismo. Porque el otro tiene el mismo resultado"_

### Evidencia en Logs

```javascript
// Usuario complet√≥ 1 quiz (3/5 correctas, 60%, 60 pts, 90 XP)

// Pero el historial muestra 2 entradas ID√âNTICAS:
üìÖ Actividad Reciente
‚óã Quiz Completado - 3/5 correctas ‚Ä¢ 60% precisi√≥n - +90 XP +60 pts
‚óã Quiz Completado - 3/5 correctas ‚Ä¢ 60% precisi√≥n - +90 XP +60 pts

// M√©tricas duplicadas:
üìù Quizzes: 2 completados      // ‚ùå Deber√≠a ser 1
üíØ 170 Puntos Totales          // ‚ùå Deber√≠a ser 110 (60 + 50 inicial)
‚ö° 180 XP Ganado               // ‚ùå Deber√≠a ser 90
```

### An√°lisis de Logs

```javascript
// Primera llamada a updateProgressAfterQuiz - SE PROCESA ‚úÖ
CxCProgressContext.js:1755 üéØ CxCProgressContext.updateProgressAfterQuiz llamado
CxCProgressContext.js:2028 ‚úÖ Estado actualizado en updateProgressAfterQuiz
  updatedProgress.totalPoints: 110
  updatedProgress.totalXP: 90
  updatedProgress.quizzesTaken: 1

// Segunda llamada - BLOQUEADA EN ResultsScreen ‚ö†Ô∏è
ResultsScreen.js:87 ‚õî Resultado ya procesado definitivamente, ignorando

// PERO: La primera llamada ya agreg√≥ la entrada al historial
// Y React est√° renderizando el componente con el estado "viejo"
```

### Causa Ra√≠z

1. **React Re-Renders Dobles**
   - `ResultsScreen` se renderiza 2 veces en modo desarrollo (StrictMode)
   - Primera renderizaci√≥n: Procesa el quiz y agrega entrada al historial
   - Segunda renderizaci√≥n: Se bloquea en ResultsScreen, pero **ya es tarde**

2. **Signature Defectuosa en Context**
   ```javascript
   // ‚ùå ANTES: Signature inclu√≠a respuestas y tiempo
   const quizSignature = JSON.stringify({
     questions: quizResults.questionDetails?.map(q => q.id).sort(),
     correctAnswers: quizResults.correctAnswers,  // ‚ùå Causa falsos negativos
     totalTime: quizResults.totalTime              // ‚ùå Cambia entre renders
   });
   ```
   
   **Problema:** Dos renders del mismo quiz ten√≠an signatures diferentes porque:
   - `correctAnswers` pod√≠a variar ligeramente
   - `totalTime` era ligeramente diferente en cada render
   
   **Resultado:** `lastProcessedQuizzesRef.current.has(quizSignature)` retornaba `false` en ambos casos

3. **Timeout Demasiado Corto**
   ```javascript
   // ‚ùå ANTES: 5 segundos
   setTimeout(() => {
     lastProcessedQuizzesRef.current.delete(quizSignature);
   }, 5000);
   ```
   
   5 segundos es insuficiente para renders retrasados o navegaci√≥n lenta

4. **Validaci√≥n en `applyProgressUpdate` Inefectiva**
   - La validaci√≥n basada en historial (`isDuplicateExact`, `isDuplicateByQuestions`) requiere que el estado ya est√© actualizado
   - Pero React batch updates hacen que el estado tarde en propagarse
   - Las dos llamadas ven el mismo historial "viejo"

---

## ‚úÖ Soluci√≥n Implementada

### üîÑ Actualizaci√≥n 2025-10-19 ‚Äî Soluci√≥n definitiva con `quizId` persistente

- Cada resultado de quiz genera un `quizId` √∫nico en `ResultsScreen`.
- `CxCProgressContext` ahora persiste todos los `quizId` procesados dentro de `progress.processedQuizIds` (guardado en autosave).
- Antes de aplicar una actualizaci√≥n se verifican dos barreras:
  1. `progress.processedQuizIds` (persistente entre sesiones) ‚Üí evita re-procesar el mismo quiz tras reinicios.
  2. `lastProcessedQuizzesRef` (en memoria) ‚Üí bloquea renders duplicados en caliente.
- Si un `quizId` ya existe en cualquiera de los conjuntos, la actualizaci√≥n se rechaza de forma idempotente.
- Tras aplicar una actualizaci√≥n correcta, el `quizId` se a√±ade al historial y a la lista persistida (manteniendo solo los √∫ltimos 200).
- El `Set` en memoria se sincroniza continuamente con la lista persistida para garantizar coherencia.

> Esta actualizaci√≥n elimina la dependencia del timestamp o de la firma de preguntas, garantizando idempotencia real incluso si el usuario completa el mismo quiz minutos despu√©s o si React vuelve a renderizar el componente. Adem√°s, mejora el rendimiento porque la detecci√≥n de duplicados se reduce a una b√∫squeda O(1) en arrays/set peque√±os.

### (Legacy) Estrategia: Signature Basada SOLO en Preguntas + Timestamp

En lugar de confiar en respuestas o tiempo (que var√≠an entre renders), usar **SOLO las preguntas + timestamp de procesamiento**:

```javascript
const questionIds = (quizResults.questionDetails?.map(q => q.id) || []).sort().join(',');
const quizSignature = `quiz_${questionIds}_${Date.now()}`;
```

### Implementaci√≥n Completa

**Archivo:** `src/contexts/CxCProgressContext.js`  
**Funci√≥n:** `updateProgressAfterQuiz()`  
**L√≠neas:** ~1754-1814

```javascript
const updateProgressAfterQuiz = useCallback((quizResults) => {
  console.log('üéØ CxCProgressContext.updateProgressAfterQuiz llamado con:', quizResults);
  
  // üÜï VALIDACI√ìN: Prevenir actualizaci√≥n duplicada con el mismo quiz
  // Usar SOLO las preguntas para la signature (independiente de respuestas/tiempo)
  const questionIds = (quizResults.questionDetails?.map(q => q.id) || []).sort().join(',');
  const quizSignature = `quiz_${questionIds}_${Date.now()}`;
  
  // IMPORTANTE: Buscar si ya procesamos ESTAS MISMAS PREGUNTAS recientemente
  // (sin importar respuestas correctas o tiempo)
  const recentQuizzes = Array.from(lastProcessedQuizzesRef.current);
  const isDuplicate = recentQuizzes.some(sig => {
    // Extraer question IDs de la signature existente
    const match = sig.match(/^quiz_([^_]+)_(\d+)$/);
    if (!match) return false;
    
    const existingQuestionIds = match[1];
    const existingTimestamp = parseInt(match[2], 10);
    
    // Es duplicado si tiene las mismas preguntas Y fue procesado en los √∫ltimos 30 segundos
    return existingQuestionIds === questionIds && 
           (Date.now() - existingTimestamp) < 30000;
  });
  
  if (isDuplicate) {
    console.warn('‚ö†Ô∏è Quiz duplicado detectado en contexto (mismas preguntas en <30s), IGNORANDO', {
      questionIds,
      recentCount: recentQuizzes.length
    });
    return {
      newAchievements: [],
      pointsEarned: 0,
      xpEarned: 0,
      levelUp: false,
      duplicate: true
    };
  }
  
  // Agregar a Set de procesados
  lastProcessedQuizzesRef.current.add(quizSignature);
  console.log('‚úÖ Quiz agregado a Set de procesados:', quizSignature);
  
  // Limpiar signatures antiguas despu√©s de 60 segundos (aumentado de 5s)
  setTimeout(() => {
    lastProcessedQuizzesRef.current.delete(quizSignature);
    console.log('üßπ Quiz removido del Set de procesados:', quizSignature);
  }, 60000);
  
  // ... resto del procesamiento del quiz
}, [applyProgressUpdate, progress, userId]);
```

### Cambios Clave

| Aspecto | Antes ‚ùå | Despu√©s ‚úÖ |
|---------|----------|------------|
| **Signature** | `{questions, correctAnswers, totalTime}` | `quiz_${questionIds}_${timestamp}` |
| **Detecci√≥n** | `JSON.stringify()` + `Set.has()` | B√∫squeda manual con regex + timestamp check |
| **Ventana** | 5 segundos | 30 segundos |
| **Criterio** | Preguntas + Respuestas + Tiempo | **SOLO Preguntas** + Timestamp |
| **Logs** | B√°sicos | Detallados con conteo |

---

## üéØ Por Qu√© Funciona

### 1. Independiente de Variaciones de Renderizado

```javascript
// Render 1: correctAnswers=3, totalTime=20000
// Render 2: correctAnswers=3, totalTime=20001  (1ms diferencia)

// ‚ùå ANTES: Diferentes signatures ‚Üí Ambos procesados

// ‚úÖ AHORA: Misma signature (solo questionIds) ‚Üí Segundo bloqueado
```

### 2. Timestamp Incorporado en Signature

```javascript
// Primera llamada: quiz_prep_avanz_005,prep_prin_007,prep_prin_008,model_inter_006,prep_inter_004_1760887935660
// Segunda llamada: quiz_prep_avanz_005,prep_prin_007,prep_prin_008,model_inter_006,prep_inter_004_1760887935661

// Aunque timestamps difieren, la comparaci√≥n busca:
// 1. Mismos questionIds ‚úÖ
// 2. Dentro de ventana de 30s ‚úÖ
// ‚Üí DUPLICADO DETECTADO
```

### 3. Ventana de 30 Segundos

```javascript
// Cubre m√∫ltiples escenarios:
// - Re-renders inmediatos (<100ms)
// - Re-renders retrasados (100ms-5s) 
// - Navegaci√≥n lenta (5s-30s)
// - Clicks accidentales dobles

// Pero NO bloquea:
// - Mismo quiz repetido intencionalmente despu√©s de 30s
// - Diferentes quizzes con diferentes preguntas
```

### 4. B√∫squeda Manual vs Set.has()

```javascript
// ‚ùå ANTES: Set.has(quizSignature)
// Requiere match EXACTO ‚Üí Fallos con timestamps diferentes

// ‚úÖ AHORA: recentQuizzes.some(sig => ...)
// Compara components de la signature individualmente
// Permite matching flexible con ventana de tiempo
```

---

## üß™ Escenarios de Verificaci√≥n

### Escenario 1: Re-Render Inmediato (React StrictMode)

```javascript
// Render 1 (t=0ms)
questionIds: "prep_avanz_005,prep_prin_007,prep_prin_008,model_inter_006,prep_inter_004"
signature: "quiz_prep_avanz_005,..._1760887935660"
‚Üí ‚úÖ PROCESADO

// Render 2 (t=50ms) - React StrictMode double render
questionIds: "prep_avanz_005,prep_prin_007,prep_prin_008,model_inter_006,prep_inter_004"
signature: "quiz_prep_avanz_005,..._1760887935710"
‚Üí ‚ö†Ô∏è DUPLICADO DETECTADO (mismos questionIds, <30s)
‚Üí ‚ùå BLOQUEADO

// Resultado:
‚úÖ 1 entrada en historial
‚úÖ 60 pts, 90 XP (no duplicados)
‚úÖ 1 quiz completado
```

### Escenario 2: Click Doble Accidental

```javascript
// Click 1 (t=0s)
‚Üí ‚úÖ PROCESADO

// Click 2 (t=2s) - Usuario clickea "Volver al men√∫" dos veces
‚Üí ‚ö†Ô∏è DUPLICADO DETECTADO (mismo quiz, <30s)
‚Üí ‚ùå BLOQUEADO

// Resultado:
‚úÖ Sin duplicaci√≥n
```

### Escenario 3: Repetir Mismo Quiz Intencionalmente

```javascript
// Quiz 1 (t=0s)
questionIds: "prep_avanz_005,prep_prin_007,..."
‚Üí ‚úÖ PROCESADO

// Usuario regresa al men√∫, selecciona mismo quiz

// Quiz 2 (t=35s) - Mismo quiz pero >30s despu√©s
questionIds: "prep_avanz_005,prep_prin_007,..."
‚Üí ‚úÖ PROCESADO (ventana de 30s expirada)

// Resultado:
‚úÖ 2 entradas en historial (v√°lido)
```

### Escenario 4: Quizzes Diferentes

```javascript
// Quiz A
questionIds: "prep_avanz_005,prep_prin_007,..."
‚Üí ‚úÖ PROCESADO

// Quiz B (t=5s) - Diferentes preguntas
questionIds: "viz_inter_008,admin_inter_005,..."
‚Üí ‚úÖ PROCESADO (diferentes questionIds)

// Resultado:
‚úÖ 2 entradas en historial (v√°lido)
```

---

## üìä Logs de Verificaci√≥n

### Antes del Fix

```javascript
// Primera llamada
üéØ CxCProgressContext.updateProgressAfterQuiz llamado
// Sin logs de detecci√≥n de duplicados
‚úÖ Estado actualizado en updateProgressAfterQuiz
  updatedProgress.quizzesTaken: 1

// Segunda llamada (desde ResultsScreen render 2)
üéØ CxCProgressContext.updateProgressAfterQuiz llamado
// Sin detecci√≥n - procesa de nuevo
‚úÖ Estado actualizado en updateProgressAfterQuiz
  updatedProgress.quizzesTaken: 2  // ‚ùå DUPLICADO
```

### Despu√©s del Fix

```javascript
// Primera llamada
üéØ CxCProgressContext.updateProgressAfterQuiz llamado
‚úÖ Quiz agregado a Set de procesados: quiz_prep_avanz_005,..._1760887935660
‚úÖ Estado actualizado en updateProgressAfterQuiz
  updatedProgress.quizzesTaken: 1

// Segunda llamada (desde ResultsScreen render 2)
üéØ CxCProgressContext.updateProgressAfterQuiz llamado
‚ö†Ô∏è Quiz duplicado detectado en contexto (mismas preguntas en <30s), IGNORANDO
  questionIds: "prep_avanz_005,prep_prin_007,prep_prin_008,model_inter_006,prep_inter_004"
  recentCount: 1
// No se actualiza el estado - retorna {duplicate: true}

// Limpieza despu√©s de 60s
üßπ Quiz removido del Set de procesados: quiz_prep_avanz_005,..._1760887935660
```

---

## üìà Impacto

### Antes del Fix

- ‚ùå Cada quiz se duplicaba ‚Üí 2 entradas en historial
- ‚ùå Puntos y XP duplicados
- ‚ùå `quizzesTaken` duplicado
- ‚ùå M√©tricas infladas incorrectamente

### Despu√©s del Fix

- ‚úÖ 1 quiz = 1 entrada en historial
- ‚úÖ Puntos y XP correctos
- ‚úÖ `quizzesTaken` correcto
- ‚úÖ M√©tricas precisas

### Comparativa de Datos

| M√©trica | Usuario Report√≥ | Esperado | Despu√©s del Fix |
|---------|----------------|----------|-----------------|
| Quizzes Completados | 2 | 1 | ‚úÖ 1 |
| Puntos Totales | 170 | 110 | ‚úÖ 110 |
| XP Total | 180 | 90 | ‚úÖ 90 |
| Entradas Historial | 2 | 1 | ‚úÖ 1 |

---

## üîç Archivos Modificados

### `src/contexts/CxCProgressContext.js`

**L√≠neas ~1754-1814:** Funci√≥n `updateProgressAfterQuiz()`

**Cambios:**
1. Signature basada solo en `questionIds` + `timestamp`
2. Comparaci√≥n manual con ventana de 30 segundos
3. Logs detallados de detecci√≥n de duplicados
4. Timeout aumentado a 60 segundos
5. Return early con objeto `{duplicate: true}`

---

## ‚úÖ Conclusi√≥n

El fix resuelve completamente el problema de duplicaci√≥n de quizzes mediante:

1. **Signature robusta:** Solo preguntas, inmune a variaciones de respuestas/tiempo
2. **Detecci√≥n inteligente:** Ventana de 30s con comparaci√≥n flexible
3. **Logs completos:** Visibilidad total del proceso de detecci√≥n
4. **Timeout extendido:** 60s para cubrir todos los escenarios edge
5. **Defensa en profundidad:** Combinado con validaciones en ResultsScreen y applyProgressUpdate

### Estado Final del Sistema

```javascript
// Procesamiento del quiz
‚úÖ Quiz √öNICO bloqueado para procesamiento (ResultsScreen)
‚úÖ Quiz agregado a Set de procesados (Context)
‚úÖ Estado actualizado en updateProgressAfterQuiz
‚ö†Ô∏è Quiz duplicado detectado en contexto, IGNORANDO (Render 2)
‚õî Resultado ya procesado definitivamente, ignorando (ResultsScreen Render 2)

// Resultado
‚úÖ 1 entrada en historial
‚úÖ M√©tricas correctas
‚úÖ Sin duplicaci√≥n
```

### Pr√≥ximos Pasos de Verificaci√≥n

1. **Limpiar datos:**
   ```javascript
   localStorage.clear();
   ```

2. **Recargar p√°gina**

3. **Completar 1 quiz**

4. **Verificar en perfil:**
   - "Actividad Reciente" debe mostrar **1 entrada**
   - "Quizzes Completados" debe mostrar **"1 completado"**
   - Puntos y XP deben ser correctos (sin duplicaci√≥n)

5. **Verificar en consola:**
   ```javascript
   ‚úÖ Quiz agregado a Set de procesados
   ‚ö†Ô∏è Quiz duplicado detectado en contexto, IGNORANDO
   ```

Si despu√©s de estos pasos el quiz a√∫n se duplica, el problema est√° en otro lugar (probablemente en la propagaci√≥n del estado de React o en un tercer render no detectado).
